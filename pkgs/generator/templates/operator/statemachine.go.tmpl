// This file is generated by VectorSigma {{ .Version }}. DO NOT EDIT.
package {{ .Package }}

import (
    "errors"
	"fmt"
	"log/slog"
	"os"

	ctrl "sigs.k8s.io/controller-runtime"
)

type (
	StateName  string
	ActionName string
	GuardName  string
)

const (
{{- range $state := .FSM.AllStates }}
	{{ $state }} StateName = "{{ $state }}"
{{- end }}
)

const (
{{- range .FSM.ActionNames }}
	{{ . }} ActionName = "{{ . }}"
{{- end }}
)

const (
{{- range .FSM.GuardNames }}
	{{ . }} GuardName = "{{ . }}"
{{- end }}
)

const maxStateDepth = 5

// Action represents a function that can be executed in a state and may return an error.
type Action struct {
	Name    ActionName
	Params  []string
	Execute func(...string) error
}

// Guard represents a function that returns a boolean indicating if a transition should occur.
type Guard struct {
	Name  GuardName
	Check  func() bool
	Action *Action
}

// StateConfig holds the actions and guards for a state.
type StateConfig struct {
	Actions     []Action
	Guards      []Guard
	Transitions map[int]StateName // Maps guard index to the next state
	Composite   CompositeState
}

type CompositeState struct {
	InitialState StateName
	StateConfigs map[StateName]StateConfig
}

// VectorSigma represents the Finite State Machine (fsm) for VectorSigma.
type {{ .FSM.Title }} struct {
	Context       *Context
	CurrentState  StateName
	ExtendedState *ExtendedState
	StateConfigs  map[StateName]StateConfig
}


// New initializes a new FSM.
func New() *{{ .FSM.Title }} {
	logLevel := new(slog.LevelVar)
	logLevel.Set(slog.LevelInfo)

	if os.Getenv("{{ .FSM.Title | toUpper }}_DEBUG") != "" {
		logLevel.Set(slog.LevelDebug)
	}

	fsm := &{{  .FSM.Title }} {
		Context:       &Context{Logger: slog.New(slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{Level: logLevel}))},
		CurrentState:  {{ .FSM.InitialState }},
		ExtendedState: &ExtendedState{},
		StateConfigs:  make(map[StateName]StateConfig),
	}

{{- define "stateConfigStructure" -}}
{
	Actions: []Action{
{{- range $action := .Actions }}
		{Name: {{ $action.Name }}, Execute: fsm.{{ $action.Name }}Action, Params: []string{ {{- $action.Params }}}},
{{- end }}
	},
	Guards: []Guard{
{{- range  $trans := .Transitions }}
	{{- if ne $trans.Guard "" }}
   	{{- if $trans.Action  }}
		{
			Name: {{ $trans.Guard }},
			Check: fsm.{{ $trans.Guard }}Guard,
			Action: &Action{
				Name: {{ $trans.Action.Name }},
				Execute: fsm.{{ $trans.Action.Name }}Action,
				Params: []string{ {{- $trans.Action.Params }}},
			},
		},
   	{{- else }}
		{Name: {{ $trans.Guard }}, Check: fsm.{{ $trans.Guard }}Guard},
   	{{- end }}
   	{{- end }}
{{- end }}
	},
	Transitions: map[int]StateName{
{{- range $ind, $trans := .Transitions }}
		{{ $ind }}: {{ $trans.Target }},
{{- end }}
	},
	{{- if ne .Composite.InitialState "" }}
	Composite: CompositeState{
		InitialState: {{ .Composite.InitialState }},
		StateConfigs: map[StateName]StateConfig{
		{{- range $subState, $subVal := .Composite.States }}
			{{- if eq $subState "FinalState" }}
				{{ continue }}
			{{- end }}
			{{ $subState }}: {{ template "stateConfigStructure" $subVal }},
		{{- end }}
		},
	},
	{{- end }}
}
{{- end -}}

{{- range $state, $val := .FSM.States }}
	{{- if eq $state "FinalState" }}
	   {{ continue }}
	{{- end }}
	fsm.StateConfigs[{{ $state }}] = StateConfig{{ template "stateConfigStructure" $val }}
{{- end }}

	return fsm
}

// Run handles the state transitions based on the current state.
func (fsm *{{ .FSM.Title }}) Run() (ctrl.Result, error) {
	return run(fsm, fsm.StateConfigs,0)
}

func run(fsm  *{{ .FSM.Title }}, stateConfigs map[StateName]StateConfig, depth int) (ctrl.Result, error) {
	if depth > maxStateDepth {
		return ctrl.Result{}, fmt.Errorf("max state depth exceeded")
	}

	for {
		// If we are in the FinalState, exit the FSM
		if fsm.CurrentState == FinalState {
			// Reset to the Initial State in case the FSM is run in a loop
			fsm.CurrentState = InitialState

			return fsm.ExtendedState.Result, fsm.ExtendedState.Error
		}

		config, exists := stateConfigs[fsm.CurrentState]

		if !exists {
			fsm.Context.Logger.Error("missing config", "state", fsm.CurrentState)

			return ctrl.Result{}, errors.New("missing state config for " + string(fsm.CurrentState))
		}

		if config.Composite.StateConfigs != nil {
			parentState := fsm.CurrentState
			// Recursively run the composite state machine
			fsm.CurrentState = config.Composite.InitialState
			fsm.Context.Logger.Debug("entering composite state", "state", parentState, "initial", fsm.CurrentState)
			_, err := run(fsm, config.Composite.StateConfigs, depth+1)
			if err != nil {
				fsm.Context.Logger.Error("composite state machine failed", "state", fsm.CurrentState, "error", err)
				fsm.ExtendedState.Error = err
			}

			fsm.Context.Logger.Debug("exiting composite state", "state", parentState )
			fsm.CurrentState = parentState
		} else {
			// Execute all actions for the current state
			err := runAllActions(fsm.Context, fsm.CurrentState, config.Actions)
			if err != nil {
				fsm.Context.Logger.Error("action failed", "state", fsm.CurrentState, "error", err)
				fsm.ExtendedState.Error = err
			}
		}

		// Check guards and determine the next state
		nextState, err := runAllGuards(fsm.Context, fsm.CurrentState, config)
		if err != nil {
			// Guarded actions will always transition to the FinalState
			fsm.ExtendedState.Error = err
			fsm.CurrentState = FinalState
		}
		if nextState != "" {
			fsm.CurrentState = nextState

			continue
		}

		// Check for unguarded transition
		if nextState, exists := config.Transitions[len(config.Guards)]; exists {
			fsm.Context.Logger.Debug("unguarded transition", "current", fsm.CurrentState, "next", nextState)
			fsm.CurrentState = nextState
		}
	}

}

func runAllActions(context *Context, currentState StateName, actions []Action) error {
	for _, action := range actions {
		context.Logger.Debug("executing", "action", action.Name, "state", currentState)

		if err := action.Execute(action.Params...); err != nil {
			return err
		}
	}

	return nil
}

func runAllGuards(context *Context, currentState StateName, config StateConfig) (StateName, error) {
	for guardIndex, guard := range config.Guards {
		if guard.Check() {
			if guard.Action != nil {
				action := guard.Action
				if err := action.Execute(action.Params...); err != nil {
					context.Logger.Debug("guarded action failed", "state", currentState,
					"guard", guard.Name, "action", action.Name, "error", err)

					return "", err
				}
			}

			// Transition to the state mapped to this guard index
			if nextState, exists := config.Transitions[guardIndex]; exists {
				context.Logger.Debug("guarded transition", "guard", guard.Name, "current", currentState, "next", nextState)

				return nextState, nil
			}
		}
	}

	return "", nil
}