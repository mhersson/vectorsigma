// This file is generated by VectorSigma. DO NOT EDIT.
package {{ .Package }}

import (
	"fmt"
	"log/slog"
	"os"
)

type (
	StateName  string
	ActionName string
	GuardName  string
)

const (
{{- range $state, $val := .FSM.States }}
	{{ $state }} StateName = "{{ $state }}"
{{- end }}
)

const (
{{- range .FSM.ActionNames }}
	{{ . }} ActionName = "{{ . }}"
{{- end }}
)

const (
{{- range .FSM.GuardNames }}
	{{ . }} GuardName = "{{ . }}"
{{- end }}
)

// Action represents a function that can be executed in a state and may return an error.
type Action struct {
	Name    ActionName
	Params  []string
	Execute func(...string) error
}

// Guard represents a function that returns a boolean indicating if a transition should occur.
type Guard struct {
	Name  GuardName
	Check func() bool
}

// StateConfig holds the actions and guards for a state.
type StateConfig struct {
	Actions     []Action
	Guards      []Guard
	Transitions map[int]StateName // Maps guard index to the next state
}

// VectorSigma represents the Finite State Machine (fsm) for VectorSigma.
type {{ .FSM.Title }} struct {
	Context       *Context
	CurrentState  StateName
	ExtendedState *ExtendedState
	StateConfigs  map[StateName]StateConfig
}


// New initializes a new FSM.
func New() *{{ .FSM.Title }} {
	logLevel := new(slog.LevelVar)
	logLevel.Set(slog.LevelInfo)

	if os.Getenv("{{ .FSM.Title | toUpper }}_DEBUG") != "" {
		logLevel.Set(slog.LevelDebug)
	}

	fsm := &{{  .FSM.Title }} {
		Context:       &Context{Logger: slog.New(slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{Level: logLevel}))},
		CurrentState:  {{ .FSM.InitialState }},
		ExtendedState: &ExtendedState{},
		StateConfigs:  make(map[StateName]StateConfig),
	}

{{- range $state, $val := .FSM.States }}
    {{- if eq $state "FinalState" }}
       {{ continue }}
    {{- end }}
	fsm.StateConfigs[{{ $state }}] = StateConfig{
		Actions: []Action{
    {{- range $action := $val.Actions }}
			{Name: {{ $action.Name }}, Execute: fsm.{{ $action.Name }}Action, Params: []string{ {{- $action.Params }}}},
    {{- end }}
		},
		Guards: []Guard{
    {{- range  $trans := $val.Transitions }}
	   {{- if eq $trans.Guard "" }}
		},
       {{- else }}
			{Name: {{ $trans.Guard }}, Check: fsm.{{ $trans.Guard }}Guard},
       {{- end }}
     {{- end }}
		Transitions: map[int]StateName{
    {{- range $ind, $trans := $val.Transitions }}
			{{ $ind }}: {{ $trans.Target }},
    {{- end }}
		},
	}
{{- end }}

	return fsm
}


// Run handles the state transitions based on the current state.
func (fsm *{{ .FSM.Title }}) Run() error {
loop:
	for {
		// If we are in the FinalState, exit the FSM
		if fsm.CurrentState == FinalState {
            // Reset to the Initial State in case the FSM is run in a loop
            fsm.CurrentState = {{ .FSM.InitialState }}

			return fsm.ExtendedState.Error
		}

		config, exists := fsm.StateConfigs[fsm.CurrentState]

		if !exists {
			fsm.Context.Logger.Error("missing config", "state", fsm.CurrentState)

			return fmt.Errorf("missing config for state: %s", fsm.CurrentState)
		}

		// Execute all actions for the current state
		for _, action := range config.Actions {
			fsm.Context.Logger.Debug("executing", "action", action.Name, "state", fsm.CurrentState)

			if err := action.Execute(action.Params...); err != nil {
				fsm.Context.Logger.Error("action failed", "action", action.Name, "state", fsm.CurrentState, "error", err)
				fsm.ExtendedState.Error = err

				break
			}
		}

		// Check guards and determine the next state
		for guardIndex, guard := range config.Guards {
			if guard.Check() {
				// Transition to the state mapped to this guard index
				if nextState, exists := config.Transitions[guardIndex]; exists {
					fsm.Context.Logger.Debug("guarded transition", "guard", guard.Name, "current", fsm.CurrentState, "next", nextState)

					fsm.CurrentState = nextState

					continue loop
				}
			}
		}
		// Check for unguarded transition
		if nextState, exists := config.Transitions[len(config.Guards)]; exists {
			fsm.Context.Logger.Debug("unguarded transition", "current", fsm.CurrentState, "next", nextState)
			fsm.CurrentState = nextState
		}
	}
}
