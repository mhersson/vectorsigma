// This file is generated by VectorSigma. DO NOT EDIT.
package fsm

import (
	"log/slog"
	"os"
)

type (
	StateName  string
	ActionName string
	GuardName  string
)

const (
	FinalState     StateName = "FinalState"
	FlashingYellow StateName = "FlashingYellow"
	Green          StateName = "Green"
	Red            StateName = "Red"
	Yellow         StateName = "Yellow"
)

const (
	SwitchIn ActionName = "SwitchIn"
)

const (
	IsError GuardName = "IsError"
)

// Action represents a function that can be executed in a state and may return an error.
type Action struct {
	Name    ActionName
	Params  []string
	Execute func(...string) error
}

// Guard represents a function that returns a boolean indicating if a transition should occur.
type Guard struct {
	Name  GuardName
	Check func() bool
}

// StateConfig holds the actions and guards for a state.
type StateConfig struct {
	Actions     []Action
	Guards      []Guard
	Transitions map[int]StateName // Maps guard index to the next state
}

// VectorSigma represents the Finite State Machine (fsm) for VectorSigma.
type TrafficLight struct {
	Context       *Context
	CurrentState  StateName
	ExtendedState *ExtendedState
	StateConfigs  map[StateName]StateConfig
}

// New initializes a new FSM.
func New() *TrafficLight {
	logLevel := new(slog.LevelVar)
	logLevel.Set(slog.LevelInfo)

	if os.Getenv("TRAFFICLIGHT_DEBUG") != "" {
		logLevel.Set(slog.LevelDebug)
	}

	fsm := &TrafficLight{
		Context:       &Context{Logger: slog.New(slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{Level: logLevel}))},
		CurrentState:  Red,
		ExtendedState: &ExtendedState{},
		StateConfigs:  make(map[StateName]StateConfig),
	}

	fsm.StateConfigs[FlashingYellow] = StateConfig{
		Actions: []Action{
			{Name: SwitchIn, Execute: fsm.SwitchInAction, Params: []string{"3"}},
		},
		Guards: []Guard{
			{Name: IsError, Check: fsm.IsErrorGuard},
		},
		Transitions: map[int]StateName{
			0: FinalState,
			1: Red,
		},
	}
	fsm.StateConfigs[Green] = StateConfig{
		Actions: []Action{
			{Name: SwitchIn, Execute: fsm.SwitchInAction, Params: []string{"5"}},
		},
		Guards: []Guard{
			{Name: IsError, Check: fsm.IsErrorGuard},
		},
		Transitions: map[int]StateName{
			0: FinalState,
			1: FlashingYellow,
		},
	}
	fsm.StateConfigs[Red] = StateConfig{
		Actions: []Action{
			{Name: SwitchIn, Execute: fsm.SwitchInAction, Params: []string{"5"}},
		},
		Guards: []Guard{
			{Name: IsError, Check: fsm.IsErrorGuard},
		},
		Transitions: map[int]StateName{
			0: FinalState,
			1: Yellow,
		},
	}
	fsm.StateConfigs[Yellow] = StateConfig{
		Actions: []Action{
			{Name: SwitchIn, Execute: fsm.SwitchInAction, Params: []string{"1"}},
		},
		Guards: []Guard{
			{Name: IsError, Check: fsm.IsErrorGuard},
		},
		Transitions: map[int]StateName{
			0: FinalState,
			1: Green,
		},
	}

	return fsm
}

// Run handles the state transitions based on the current state.
func (fsm *TrafficLight) Run() {
transitionsLoop:
	for {
		// If we are in the FinalState, exit the FSM
		if fsm.CurrentState == FinalState {
			// Reset to the Initial State in case the FSM is run in a loop
			fsm.CurrentState = Red
			return
		}

		config, exists := fsm.StateConfigs[fsm.CurrentState]

		if !exists {
			fsm.Context.Logger.Error("missing state config", "state", fsm.CurrentState)

			return
		}

		// Execute all actions for the current state
		for _, action := range config.Actions {
			fsm.Context.Logger.Debug("executing", "action", action.Name, "state", fsm.CurrentState)

			if err := action.Execute(action.Params...); err != nil {
				fsm.Context.Logger.Error("action failed", "action", action.Name, "state", fsm.CurrentState, "error", err)
				fsm.ExtendedState.Error = err

				break
			}
		}

		// Check guards and determine the next state
		for guardIndex, guard := range config.Guards {
			if guard.Check() {
				// Transition to the state mapped to this guard index
				if nextState, exists := config.Transitions[guardIndex]; exists {
					fsm.Context.Logger.Debug("guarded transition", "guard", guard.Name, "current", fsm.CurrentState, "next", nextState)

					fsm.CurrentState = nextState

					continue transitionsLoop
				}
			}
		}
		// Check for unguarded transition
		if nextState, exists := config.Transitions[len(config.Guards)]; exists {
			fsm.Context.Logger.Debug("unguarded transition", "current", fsm.CurrentState, "next", nextState)
			fsm.CurrentState = nextState
		}
	}
}
